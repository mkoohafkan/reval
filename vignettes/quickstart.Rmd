%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{quickstart}

```{r include=FALSE}
require(knitr)
require(reval)
opts_chunk$set(tidy=TRUE, message=FALSE)
```

Quickstart for reval
====================

Introduction
------------
This vignette will get you stated using `reval` by showing a moderately-complex 
example. Additional examples are available in the function documentation for
`evalmany`.

Example: Channel design sensitivity analysis
--------------------------------------------

In-stream structures such as dams, weirs and culverts modify flows in a river. 
In large rivers with tranquil flows, such structures can affect the river stage
(water depth) many miles upstream. These water surface profiles or "backwater 
curves" can be modelled using well-understood hydraulic relationships. One 
important parameter---a coefficient representing the texture or "roughness" of 
the river bed---is empirical and cannot be easily measured. Therefore it is 
often important for engineers to compute these backwater curves for a range of
roughness values in order to establish confidence limits for planning and 
management purposes.

The `rivr` package provides the function `compute_profile` for modelling 
the backwater curve in a channel with unchanging geometry, given a known water 
depth at a specified location. Computing a single profile would look something 
like this: 

```{r single, results="hide"}
# install.packages("rivr")
require(rivr)
compute_profile(So = 0.001, n = 0.045, Q = 250, y0 = 2.7, Cm = 1.486, g = 32.2, 
  B = 100, SS = 0, stepdist = 50, totaldist = 3000)
```

In order to perform a sensitivity analysis on the effect of the roughness 
parameter on the backwater curve, we would need to loop through a series 
of roughness values (the argument `n`) and compile the results for comparison.
This could be accomplished with a simple for loop: 

```{r loop}
ns = seq(0.03, 0.06, by = 0.005)
results = vector("list", length=length(ns))
for(i in 1:length(ns)){
  results[[i]] = compute_profile(So = 0.001, n = ns[i], Q = 250, y0 = 2.7, 
    Cm = 1.486, g = 32.2, B = 100, SS = 0, stepdist = 50, totaldist = 3000)
  # add an identifier to the result
  results[[i]]["n"] = ns[i]
}
combined = do.call(rbind.data.frame, results)
```
 
That wasn't too bad, but it's even easier with `reval`---we can replace that
entire chunk of code with a single call to `evalmany`:

```{r reval-single}
results = evalmany(compute_profile, n = seq(0.03, 0.06, by = 0.005),
  default.args = list(So = 0.001, Q = 250, y0 = 2.7, 
  Cm = 1.486, g = 32.2, B = 100, SS = 0, stepdist = 50, totaldist = 3000))
```

What if we needed to investigate other parameters in 
as well as the roughness coefficient? If we wanted to stick to using loops, we 
would need an additional loop for every variable, impacting readability and 
making code maintenance a hassle. But extending the analysis to multiple 
variables is trivial with `reval`:

```{r reval-multi}
results = evalmany(compute_profile, n = seq(0.03, 0.06, by = 0.005),
  So = c(0.001, 0.0015), default.args = list(Q = 250, 
  y0 = 2.7, Cm = 1.486, g = 32.2, B = 100, SS = 0, stepdist = 50, 
  totaldist = 3000), method = "permute", collate.id = "multi")
```

`reval` can also add identifiers automatically, which makes plotting easy.

```{r plot-curves, fig.width=10, dpi=200}
require(ggplot2)
ggplot(results, aes(x = x, y = y, color = factor(n))) + geom_line() + 
  facet_wrap(~So)
```

The identifiers can also be used for data subsetting and extraction, e.g. using 
`dplyr`.

```{r reval-extract, results="hide"}
require(dplyr)
filter(results, n == 0.045, So == 0.0015)
``` 

Alternatively, the raw results can be output as a named list using the argument
`collate = FALSE`. For more intensive computations, parallel processing 
capabilities via the `doParallel` package can accessed using the argument 
`clusters`. 


Still confused? 
---------------

Check out the `evalmany` function documentation for more 
examples.
