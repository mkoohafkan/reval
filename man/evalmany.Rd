% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/reval.r
\name{evalmany}
\alias{evalmany}
\title{Repeated evaluations}
\usage{
evalmany(fun, ..., method = c("ofat", "permute", "set"), sample = 0L,
  default.args = list(), collate = TRUE, collate.id = c("single",
  "multi"), collate.fun = identity, clusters = 1L)
}
\arguments{
\item{fun}{The function to be evaluated.}

\item{...}{Arguments to be varied when evaluating \code{fun}, where each
argument in '\code{...}' is a (named) vector or list of values. Lists of
multi-value objects (e.g. data.frames) should be named explicitly and may
otherwise produce unexpected or incorrect names.}

\item{method}{The sensitivity analysis method to be used. Can be either
one-factor-at-a-time ("ofat") evaluation, evaluation of parameter sets
("set"), or (sampled) permutations of parameter sets ("permute"). When
\code{method = "ofat"}, the first element of each argument in '\code{...}'
is assumed to be the "default" value of that argument.}

\item{sample}{If \code{method = "permute"}, the number of parameter
permutations to evaluate (sampling without replacement).
If \code{sample < 1} (the default) then all possible permutations are
evaluated.}

\item{default.args}{The default values of arguments passed to \code{fun}.}

\item{collate}{Whether to collate the results or not. If TRUE, output
elements will be coerced into data.frames using \code{as.data.frame}.
Otherwise, the raw outputs will be returned as a named list.}

\item{collate.id}{If \code{collate = TRUE}, the method used to
store the evaluation identifiers. If \code{collate.id = "single"}, a
single column is used. If \code{collate.id = "multi"}, one column is
created for each argument in '\code{...}'.}

\item{collate.fun}{If \code{collate = TRUE}, an optional function
for reshaping the output of each evaluation prior to coercing and
collating the outputs.}

\item{clusters}{Number of clusters to use for parallel processing. Default
  is 1 (serial computation).}
}
\value{
If \code{collate = TRUE}, a data.frame. Otherwise, a named list.
}
\description{
Evaluate a function repeatedly across argument sets or permutations.
}
\examples{
set.seed(1459)
myfun = function(...){
  x = rnorm(...)
  data.frame(mean = mean(x), sd = sd(x))
}
evalmany(myfun, mean = c(5, 9), sd = c(2, 3), default.args = list(n = 1e6))
evalmany(myfun, mean = c(5, 9), sd = c(2, 3), default.args = list(n = 1e6),
  collate.id = "multi")
evalmany(myfun, mean = seq(20), sd = seq(1, 4, by = 0.1),
  default.args = list(n = 1e6), method = "permute", sample = 10)

# vector recycling
evalmany(myfun, mean = c(0, 3, 5), sd = c(1, 10),
  default.args = list(n = 1e6), method = "set", collate.id = "multi")

# Parallel processing
evalmany(myfun, mean = seq(0, 50, by = 10), sd = seq(1, 10, by = 1.5),
  default.args = list(n = 1e5), method = "permute", collate.id = "multi",
  clusters = 2)

\dontrun{
# Complex objects and error handling
formulas = list(y ~ 1, y ~ x, y ~ I(x^2), y ~ x + z)
datasets = list(
  A = data.frame(x = seq(0, 99), y = seq(0, 99) + rnorm(100)),
  B = data.frame(x = seq(0, 99), y = seq(0, 99) + rnorm(100, mean = 5)),
  C = data.frame(x = seq(0, 99), y = seq(0, 99) + rlnorm(100, meanlog = 1))
)
# raw output
evalmany(lm, formula = formulas, data = datasets, method = "set",
  collate = FALSE)
# data extraction
evalmany(lm, formula = formulas, data = datasets, method = "permute",
  collate.id = "multi", collate.fun = function(x)
    data.frame(param = names(x$coefficients), value = x$coefficients,
    row.names=NULL))
}
}

